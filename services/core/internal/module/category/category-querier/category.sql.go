// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: category.sql

package categoryQuerier

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createOne = `-- name: CreateOne :one
INSERT INTO category (name, slug, status, created_at, updated_at)
VALUES ($1, $2, $3, NOW(), NOW())
RETURNING id, name, slug, status, created_at, updated_at
`

type CreateOneParams struct {
	Name   string
	Slug   string
	Status string
}

func (q *Queries) CreateOne(ctx context.Context, arg CreateOneParams) (Category, error) {
	row := q.db.QueryRowContext(ctx, createOne, arg.Name, arg.Slug, arg.Status)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteOne = `-- name: DeleteOne :exec
DELETE FROM category
WHERE id = $1
`

func (q *Queries) DeleteOne(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteOne, id)
	return err
}

const getMany = `-- name: GetMany :many
SELECT id, name, slug, status, created_at, updated_at
FROM category
WHERE
  (
    ($1::text IS NOT NULL AND name = $1)
    OR
    ($2::text IS NOT NULL AND name ~* $2::text)
    OR
    ($1::text IS NULL AND $2 IS NULL)
  )
  AND
  (
    ($3::text IS NOT NULL AND slug = $3)
    OR
    ($4::text IS NOT NULL AND slug ~* $4::text)
    OR
    ($3::text IS NULL AND $4 IS NULL)
  )
  AND
  (
    status = $5 OR $5 IS NULL
  )
ORDER BY
  CASE WHEN $6::text = 'name__asc' THEN name END ASC,
  CASE WHEN $6::text = 'name__desc' THEN name END DESC,
  CASE WHEN $6::text = 'created_at__asc' THEN created_at END ASC,
  CASE WHEN $6::text = 'created_at__desc' THEN created_at END DESC,
  CASE WHEN $6::text = 'updated_at__asc' THEN updated_at END ASC,
  CASE WHEN $6::text = 'updated_at__desc' THEN updated_at END DESC,
  CASE WHEN $6::text = 'status__asc' THEN status END ASC,
  CASE WHEN $6::text = 'status__desc' THEN status END DESC
LIMIT $8 OFFSET $7
`

type GetManyParams struct {
	NameEq    sql.NullString
	NameRegex sql.NullString
	SlugEq    sql.NullString
	SlugRegex sql.NullString
	Status    sql.NullString
	SortQuery sql.NullString
	Offset    sql.NullInt32
	Limit     sql.NullInt32
}

func (q *Queries) GetMany(ctx context.Context, arg GetManyParams) ([]Category, error) {
	rows, err := q.db.QueryContext(ctx, getMany,
		arg.NameEq,
		arg.NameRegex,
		arg.SlugEq,
		arg.SlugRegex,
		arg.Status,
		arg.SortQuery,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Category
	for rows.Next() {
		var i Category
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getManyByIds = `-- name: GetManyByIds :many
SELECT id, name, slug, status, created_at, updated_at FROM category
WHERE id = ANY($1::uuid[])
`

func (q *Queries) GetManyByIds(ctx context.Context, dollar_1 []uuid.UUID) ([]Category, error) {
	rows, err := q.db.QueryContext(ctx, getManyByIds, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Category
	for rows.Next() {
		var i Category
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOneById = `-- name: GetOneById :one
SELECT id, name, slug, status, created_at, updated_at FROM category
WHERE id = $1
`

func (q *Queries) GetOneById(ctx context.Context, id uuid.UUID) (Category, error) {
	row := q.db.QueryRowContext(ctx, getOneById, id)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateOneById = `-- name: UpdateOneById :one
UPDATE category SET
  name = coalesce($1, name),
  slug = coalesce($2, slug),
  status = coalesce($3, status),
  updated_at = now()
WHERE id = $4 RETURNING id, name, slug, status, created_at, updated_at
`

type UpdateOneByIdParams struct {
	Name   sql.NullString
	Slug   sql.NullString
	Status sql.NullString
	ID     uuid.UUID
}

func (q *Queries) UpdateOneById(ctx context.Context, arg UpdateOneByIdParams) (Category, error) {
	row := q.db.QueryRowContext(ctx, updateOneById,
		arg.Name,
		arg.Slug,
		arg.Status,
		arg.ID,
	)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
